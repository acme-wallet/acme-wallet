# USE CASE GENERATOR

---
name: create-use-case
description: Aplicar quando criar um novo use case, baseado nas regras de injeção de dependência do DDD
---

## O QUE ESSA SKILL FAZ

- **Use Cases**: Uma classe com princípio da responsabilidade única, com um método `execute()`
- **Controller**: Controlador HTTP que chama o use case
- **Repository**: Implementação concreta do repositório do domínio
- **Testes de Unidade**: 1 teste por classe (use case, controller e repository)

## QUANDO USAR ESSA SKILL

Use quando você precisar adicionar um novo use case seguindo o pattern atual.

## USE CASE PATTERN

```typescript
import { MyEntity } from "src/contexts/context.entity";
import { IEntityRepository } from "src/contexts/context/domain.repository";
import { Injectable } from "@nestjs/common";

@Injectable()
export default class ActionEntityUseCase {
    constructor(private readonly entityRepo: IEntityRepository) {}

    async execute(input: Input): Promise<Output> {
        const output = new MyEntity(input.field1, input.field2);

        await this.entityRepo.create(output);

        return {
            id: output.id,
        }
    }
}

type Input = {
    field1: string;
    field2: string;
}

type Output = {
    id: string;
}
```

## CONTROLLER PATTERN
```javascript
import { Controller, Post, Body, UsePipes } from '@nestjs/common';
import { ZodValidationPipe } from 'nestjs-zod';
import ActionEntityUseCase from 'src/context/application/use-cases/action-entity.use-case';
import { ActionEntityDto } from '../dto/context/action-entity.dto';

@Controller('entity')
export class EntityController {
  constructor(private readonly actionEntityUseCase: ActionEntityUseCase) {}

  @Post()
  @UsePipes(ZodValidationPipe)
  create(@Body() body: ActionEntityDto) {
    const input = {
      field1: body.field1,
      field2: body.field2,
    }
    return this.actionEntityUseCase.execute(input);
  }

}

```

### REPOSITORY PATTERN
```typescript
import { Injectable } from "@nestjs/common";
import { Entity } from "src/contexts/context/domain/entities/entity.entity";
import { IEntityRepository } from "src/contexts/context/domain/repositories/entity.repository";
import { PrismaService } from "src/prisma/prisma.service";

@Injectable()
export class EntityPrismaRepository implements IEntityRepository {
    constructor(private readonly prismaService: PrismaService) {}

    async create(entity: Entity): Promise<{ id: string; }> {
        const output = await this.prismaService.prisma.entity.create({
            data: {
                id: entity.id,
                field1: entity.field1,
                field2: entity.field2,
            },
        });

        return {
            id: output.id,
        };
    }
}
```

## Regras de Injeção de Dependência

**Use Cases** e **Repositories**: injetados no módulo `src/{domain}/{domain}.module.ts`
```typescript
import { Module } from '@nestjs/common';
import ActionEntityUseCase from './application/use-cases/action-entity.use-case';
import { IEntityRepository } from "src/contexts/context/domain/repositories/entity.repository";
import { DomainController } from './interfaces/http/domain.controller';
import { DomainPrismaRepository } from './infra/repositories/domain-prisma.repository';
import { PrismaService } from '../prisma/prisma.service';

@Module({
  controllers: [DomainController],
  providers: [
    ActionEntityUseCase,
    PrismaService,
    {
      provide: IEntityRepository,
      useClass: DomainPrismaRepository,
    }
  ],
})

export class DomainModule {}
```

## Regras Críticas

**Você deve:**
- Adicionar `Injectable()`
- Manter uma única função pública `execute()`
- Definir `Input` e `Output`
- Retornar objetos puros (não entidades)
- Criar o contrato do repositório e o método no controller se não existirem
- Criar 1 teste simples para use case, controller e repository

**Você não deve:**
- Misturar validação de HTTP no repository
- Retornar entidades do domínio diretamente

## TESTES

Framework: Jest + `@nestjs/testing` + `jest-mock-extended`

Escopo minimo: 1 teste por classe

- Use case: valida chamada do repositorio mock e retorno do output
- Controller: valida status code e formato do retorno
- Repository: valida chamada do client mock

## EXEMPLOS DE TESTE

### Use case (1 teste)
```typescript
describe("UseCase", () => {
  it("calls repository and returns output", async () => {
    // arrange: mock repo + sut
    // act: sut.execute(input)
    // assert: repo called, output shape
  });
});
```

### Controller (1 teste)
```typescript
describe("Controller (HTTP)", () => {
  it("POST /entities - returns 201 and payload", async () => {
    // arrange: app + override repo provider
    // act: request(app).post("/entities").send(payload)
    // assert: status 201, response body shape
  });
});
```

### Repository (1 teste)
```typescript
describe("Repository", () => {
  it("calls client and returns id", async () => {
    // arrange: prisma mock + repo
    // act: repo.create(entity)
    // assert: client called, output shape
  });
});
```

## Checklist de validacao

- [ ] Todos os use case tem `@Injectable()`
- [ ] Todos os use case tem um metodo publico `execute()`
- [ ] Foi gerado 1 teste de unidade para use case, repository e controller
- [ ] Testes em `*.spec.ts` ao lado do arquivo testado
- [ ] Stack de teste: Jest + `@nestjs/testing` + `jest-mock-extended`
- [ ] Use cases injected by class
- [ ] Input/Output definidos
- [ ] Retorna objetos puros
